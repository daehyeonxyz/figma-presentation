// ============================================================
// FIGMA PRESENTATION GENERATOR
// Auto-generated by figma-ppt-plugin for Claude Code
// https://github.com/your-username/figma-ppt-plugin
//
// HOW TO RUN:
//   1. Open Figma desktop app
//   2. Plugins → Development → Open Console (Mac: Opt+Cmd+I)
//   3. Paste this entire file and press Enter
// ============================================================

(async () => {

  // ---- STYLE GUIDE (extracted from Figma or default) ----
  const STYLE = {{STYLE_JSON}};

  // ---- SLIDE DATA ----
  const SLIDES = {{SLIDES_JSON}};

  // ---- PRESENTATION TITLE ----
  const TITLE = "{{PRESENTATION_TITLE}}";

  // ============================================================
  // HELPER FUNCTIONS
  // ============================================================

  function hex(h) {
    h = (h || '#888888').replace('#', '');
    if (h.length === 3) h = h.split('').map(c => c + c).join('');
    return {
      r: parseInt(h.slice(0, 2), 16) / 255,
      g: parseInt(h.slice(2, 4), 16) / 255,
      b: parseInt(h.slice(4, 6), 16) / 255
    };
  }

  function solid(hexColor) {
    return [{ type: 'SOLID', color: hex(hexColor) }];
  }

  function solidAlpha(hexColor, alpha) {
    return [{ type: 'SOLID', color: hex(hexColor), opacity: alpha }];
  }

  function gradient(fromHex, toHex, angle) {
    // angle: 0 = top→bottom, 90 = left→right
    const rad = (angle || 0) * Math.PI / 180;
    const cos = Math.cos(rad), sin = Math.sin(rad);
    return [{
      type: 'GRADIENT_LINEAR',
      gradientTransform: [[cos, sin, (1 - cos) / 2 - sin / 2], [-sin, cos, sin / 2 + (1 - cos) / 2]],
      gradientStops: [
        { position: 0, color: { ...hex(fromHex), a: 1 } },
        { position: 1, color: { ...hex(toHex), a: 1 } }
      ],
      visible: true, opacity: 1, blendMode: 'NORMAL'
    }];
  }

  function px(n) { return Math.round(n); }

  const W = STYLE.layout.slideWidth || 1920;
  const H = STYLE.layout.slideHeight || 1080;
  const P = STYLE.layout.contentPadding || { top: 80, right: 96, bottom: 80, left: 96 };
  const HDR = STYLE.layout.headerHeight || 128;
  const GAP = STYLE.layout.columnGap || 48;
  const IGAP = STYLE.layout.itemGap || 24;
  const CR = STYLE.layout.cornerRadius || 12;

  async function loadFont(family, style) {
    try {
      await figma.loadFontAsync({ family, style });
    } catch {
      try { await figma.loadFontAsync({ family, style: 'Regular' }); } catch {}
    }
  }

  async function preloadAllFonts() {
    const styles = ['Thin', 'ExtraLight', 'Light', 'Regular', 'Medium', 'SemiBold', 'Bold', 'ExtraBold', 'Black',
                    'Italic', 'Bold Italic', 'Medium Italic', 'Light Italic'];
    const families = new Set(
      Object.values(STYLE.typography || {})
        .filter(v => v && v.fontFamily)
        .map(v => v.fontFamily)
    );
    families.add('Inter'); // always load Inter as fallback

    const loads = [];
    for (const family of families) {
      for (const s of styles) {
        loads.push(figma.loadFontAsync({ family, style: s }).catch(() => {}));
      }
    }
    await Promise.all(loads);
  }

  function makeFrame(name, index) {
    const f = figma.createFrame();
    f.name = `${String(index + 1).padStart(2, '0')} — ${name}`;
    f.resize(px(W), px(H));
    f.x = index * px(W + (STYLE.layout.frameSpacing || 80));
    f.y = 0;
    f.fills = solid(STYLE.colors.background || '#FFFFFF');
    f.cornerRadius = 0;
    f.clipsContent = true;
    return f;
  }

  async function addText(parent, content, typo, x, y, maxWidth) {
    if (!content) return null;
    const t = figma.createText();
    parent.appendChild(t);

    const family = typo.fontFamily || 'Inter';
    const style = typo.fontStyle || 'Regular';
    await loadFont(family, style);

    t.fontName = { family, style };
    t.characters = String(content);
    t.fontSize = typo.fontSize || 18;
    t.fills = solid(typo.colorOverride || STYLE.colors.text.primary || '#1A1A2E');

    if (typo.lineHeight) {
      t.lineHeight = { unit: 'PERCENT', value: typo.lineHeight * 100 };
    }
    if (typo.letterSpacing) {
      t.letterSpacing = { unit: 'PIXELS', value: typo.letterSpacing };
    }
    if (typo.textTransform === 'uppercase') {
      t.textCase = 'UPPER';
    }

    t.x = px(x);
    t.y = px(y);

    if (maxWidth) {
      t.textAutoResize = 'HEIGHT';
      t.resize(px(maxWidth), t.height);
    }
    return t;
  }

  function addRect(parent, x, y, w, h, fillHex, radius, alpha) {
    const r = figma.createRectangle();
    parent.appendChild(r);
    r.x = px(x); r.y = px(y);
    r.resize(px(Math.max(w, 1)), px(Math.max(h, 1)));
    if (alpha !== undefined && alpha < 1) {
      r.fills = solidAlpha(fillHex, alpha);
    } else {
      r.fills = solid(fillHex);
    }
    if (radius) r.cornerRadius = radius;
    return r;
  }

  function addEllipse(parent, x, y, w, h, fillHex, alpha) {
    const e = figma.createEllipse();
    parent.appendChild(e);
    e.x = px(x); e.y = px(y);
    e.resize(px(w), px(h));
    if (alpha !== undefined) {
      e.fills = solidAlpha(fillHex, alpha);
    } else {
      e.fills = solid(fillHex);
    }
    return e;
  }

  function headerBar(f, sectionLabel, heading, slideIndex) {
    // Full-width header bar
    addRect(f, 0, 0, W, HDR, STYLE.colors.primary || '#2D3FE0');
    // Bottom accent line
    addRect(f, 0, HDR, W, 4, STYLE.colors.secondary || STYLE.colors.primaryDark || STYLE.colors.primary || '#6B7FFF');

    const textInverse = STYLE.colors.text.inverse || '#FFFFFF';

    if (sectionLabel) {
      const captTypo = {
        ...(STYLE.typography.caption || STYLE.typography.body || {}),
        fontSize: 12,
        fontStyle: 'SemiBold',
        letterSpacing: 4,
        colorOverride: textInverse + '88'
      };
      addText(f, (sectionLabel).toUpperCase(), captTypo, P.left, 22, W - P.left * 2);
    }

    const headingTypo = {
      ...(STYLE.typography.heading2 || STYLE.typography.heading1 || {}),
      fontStyle: 'Bold',
      colorOverride: textInverse
    };
    addText(f, heading, headingTypo, P.left, sectionLabel ? 44 : 32, W - P.left - P.right - 60);

    // Slide number (top right)
    const numTypo = {
      fontFamily: STYLE.typography.heading1?.fontFamily || 'Inter',
      fontStyle: 'Bold',
      fontSize: 13,
      colorOverride: textInverse + '44'
    };
    addText(f, String(slideIndex + 1).padStart(2, '0'), numTypo, W - P.right - 32, 24, 32);
  }

  // ============================================================
  // SLIDE BUILDER FUNCTIONS
  // ============================================================

  {{SLIDE_BUILDER_FUNCTIONS}}

  // ============================================================
  // DISPATCH MAP
  // ============================================================

  const BUILD = {
    HERO:    buildHero,
    AGENDA:  buildAgenda,
    CONTENT: buildContent,
    TWO_COL: buildTwoCol,
    STATS:   buildStats,
    QUOTE:   buildQuote,
    DIVIDER: buildDivider,
    CLOSING: buildClosing
  };

  // ============================================================
  // MAIN EXECUTION
  // ============================================================

  try {
    console.log('figma-ppt: Loading fonts...');
    await preloadAllFonts();

    // Create new page
    const page = figma.createPage();
    page.name = TITLE;
    figma.currentPage = page;

    for (let i = 0; i < SLIDES.length; i++) {
      const slide = SLIDES[i];
      console.log(`Building slide ${i + 1}/${SLIDES.length}: [${slide.type}] ${slide.content?.title || slide.content?.heading || ''}`);
      const builder = BUILD[slide.type];
      if (builder) {
        await builder(slide.content || {}, i);
      } else {
        console.warn(`Unknown slide type: ${slide.type}. Skipping.`);
      }
    }

    figma.viewport.scrollAndZoomIntoView(page.children);
    figma.notify(`Created ${SLIDES.length} slides on page "${page.name}"`, { timeout: 5000 });
    console.log('figma-ppt: Done!');
  } catch (err) {
    console.error('figma-ppt Error:', err);
    figma.notify('Error generating slides. Open console for details.', { error: true });
  }

})();
